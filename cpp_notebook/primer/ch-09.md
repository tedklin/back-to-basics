# chapter 9: sequential containers

Primer seems to serve as a good standalone reference for info on sequential containers. As opposed to previous notes whose purpose is to be a (mostly) thorough reference, this will just be a non-exhaustive collection of serious pitfalls to watch out for and good practices to keep in mind when dealing with sequential containers.

## main core ideas

- **container elements are copies.** just like when we pass an object by value, there is no relationship between the element in the container and the object from which that value originated!
- **iterator ranges are of the form [b, e).**
- **don't use subscripts out of range.**
- **be wary of <ins>any</ins> access operation on an *empty* container.**
	- behavior is undefined, so compiler likely won't even tell you something's wrong.
		- refer back to ch3, especially [sections on vectors and iterators](https://github.com/tedklin/pseudoblog/blob/master/cpp_notebook/primer/ch-03.md#library-vector-type-33).
- sequential container **access operations return references**.
	- if the container is const, then access returns a reference to const.
	- if we use auto, we must still explicitly declare it a reference if we want to use it as such.
- **keep in mind that operations that add or remove elements may invalidate iterators, pointers, or references to other elements.**
	- using an invalidated iterator/pointer/reference is a serious run-time error.
	- avoid looping directly over the container you add to / remove from.
		- if you really need to do so, make sure that every iteration recalculates *end()* and updates iterators correctly.


## misc conventions and tips

- library swap is fast! also get into the habit of using the nonmember version of swap because generic programs will likely use it. 
	- *std::swap(c1, c2)* instead of *c1.swap(c2)*
- recall relational operators are dictionary ordered!
- [converting between strings and other types.](https://en.cppreference.com/w/cpp/string/basic_string/stol)