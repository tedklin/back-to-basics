# chapter 13: copy control

## copy, assign, destroy (13.1)

### main core ideas
- a constructor is the ***copy constructor*** if its first parameter is a **reference to its class-type** and any additional parameters have default values.
	- the parameter is usually a reference to const.
	- usually not *explicit* (copy constructor is often used implicitly).
	- if not manually defined, the copy constructor is **always** synthesized! (as opposed to [synthesized default constructors](https://github.com/tedklin/pseudoblog/blob/master/cpp_notebook/primer/ch-07.md#constructors))
		- the synthesized copy constructor performs (nonstatic) memberwise copying (using each member's respective copy constructor).
	- copy constructors are used in [copy initialization](https://github.com/tedklin/pseudoblog/blob/master/cpp_notebook/primer/ch-02.md#variables-22) (and direct initialization?).
~~~
// example copy constructor declaration
class Foo {
	Foo(const Foo& foo);
};
~~~

- the ***copy-assignment operator*** is a function overload of the = operator.
	- for consistency purposes, assignment operators ordinarily should return a reference to their left-hand operand (return *\*this*).
	- if not manually defined, the copy-assignment operator is **always** synthesized.
		- the synthesized version performs (nonstatic) memberwise assignment (using each member's respective copy-assignment operator).
		- also returns a reference to its left-hand operand.
~~~
// example copy-assignment operator overload declaration
class Foo {
public:
	Foo& operator=(const Foo& right_hand_operand);
};
~~~

- the ***destructor*** frees the resources used by an object and destroys the nonstatic data members of the object.
	- destructors are automatically called when things are destroyed:
		- variables are destroyed when they go out of scope.
		- members of an object are destroyed when the object of which they are a part is destroyed.
		- elements in a container—whether a library container or an array—are destroyed when the container is destroyed.
		- dynamically allocated objects are destroyed when the *delete* operator is applied to a pointer to the object.
		- temporary objects are destroyed at the end of the full expression in which the temporary was created.
		- **note that an object's destructor is not run when a reference or a pointer (to that object) goes out of scope (or is destroyed in general?).**
	- **the destructor runs its function body first, then <ins>implicitly</ins> performs memberwise destruction (calls destructors for class-type members, does nothing for built-in type members)**.
		- note that the implicit destruction of a built-in (raw) pointer does not delete the object to which that pointer points (we have to [clean up manually](https://github.com/tedklin/pseudoblog/blob/master/cpp_notebook/primer/ch-12.md#direct-memory-management)).
		- [smart pointers](https://github.com/tedklin/pseudoblog/blob/master/cpp_notebook/primer/ch-12.md) are class-type members that have their own destructors, so we don't have to worry about manually cleaning them up.
	- if not manually defined, the destructor is **always** synthesized.
		- the synthesized version is just a destructor with an empty body (memberwise destruction is always implicitly performed).
~~~
// example destructor declaration
class Foo {
public:
	~Foo();
};
~~~

- ***= default*** explicitly asks the compiler to generate the synthesized versions of the copy-control members (similar to = default for the default constructor).
- ***deleted functions*** are ones that are declared but cannot be used in any other way. (C++11)
	- defined with ***= delete***
	- specifically, we can use make the copy constructor and copy assignment operator deleted functions to prevent copies.
		- never make the destructor a deleted function unless for very good reason.
	- in general, if a class has any data member that cannot be default constructed, copied, assigned, or destroyed, then the corresponding member function will be synthesized as a deleted function.
		- in particular, note that if a class has a const or reference member, the synthesized copy-assignment operator will be implicitly defined as deleted.

### misc stuff in Primer
- *value-like* vs *pointer-like* classes.
	- see Primer for details.
- *swap* function and *copy-and-swap* technique for classes that allocate dynamic memory.

### misc conventions and tips
- [**rule of three/five/zero**](https://en.cppreference.com/w/cpp/language/rule_of_three) to determine when classes need to define their own (non-synthesized) versions of copy-control members
	- for example, if a ("value-like") class needs to define a (non-synthesized) destructor (i.e. to free memory directly), it almost surely also needs to define a (non-synthesized) copy-assignment operator and copy constructor (to make sure copies don't all have raw pointers to the same object).
- the copy-assignment operator often does the same work as is needed in the copy constructor and destructor. in such cases, the common
work should be put in private utility functions.
- before C++11, similar effects to *deleted functions* were achieved by making the corresponding functions private.


## move semantics (13.6)

### main core ideas
- use cases of *move*:
	- when an object would be immediately destroyed after it is copied, moving would alternatively provide better performance.
		- i.e. [moving a shared_ptr for optimization](https://stackoverflow.com/questions/41871115/why-would-i-stdmove-an-stdshared-ptr)
	- classes (like *unique_ptr*) that exhibit "ownership" and don't share their resource need to be moved instead of copied.
- ***rvalue references***
	- obtained by using && instead of & (for [lvalue reference](https://github.com/tedklin/pseudoblog/blob/master/cpp_notebook/primer/ch-02.md#compound-types-23)) as the type.
		- ***std::move*** function returns an rvalue reference to its given (lvalue) object.
			- tells the compiler that we have an lvalue that we want to treat as if it were an rvalue.
			- **std::move essentially promises the compiler that we do not intend to use the moved-from object (lvalue) again in any way except to assign to it or to destroy it.**
	- rvalue references may be bound only to an object that is about to be destroyed (literals, the results of certain expressions, anything that is not an lvalue).
		- this is the opposite of binding rules for normal lvalue references and more like the binding rules for lvalue references to const.
		- note that **all** variables are lvalues, even variables that have rvalue reference type.
	- because rvalue references can only be bound to temporaries, we know that the referred-to object is about to be destroyed and there can be no other users of that object.
		- as a result, we are free to “move” resources from an rvalue reference to another object.
		- we can also think of this as we can "steal" or "take over" resources from an object bound to an rvalue reference.
~~~
// examples of legal rvalue reference bindings
int &&rr1 = 42;
int &&rr2 = i * 42;
int &&rr3 = std::move(rr1);
~~~
- to enable move operations for our own types, we define the move copy-control members: **move constructor** and **move-assignment operator**. 
	- these members are similar to the corresponding copy operations, but they “steal” resources from their given object rather than copy them.
	- move copy-control members that are not expected to throw exceptions should be marked as ***noexcept*** (after the parameter list).
	- **after a move operation, the “moved-from” object must remain a *valid*, *destructible* object, but users may make no assumptions about its value (and shouldn't use it any way other than to assign to it or destroy it).**
		- **move copy-control members must ensure that the moved-from object is left in a state such that destroying that object will be harmless.**
			- i.e. setting the moved-from object's raw pointers to nullptr, so destroying the moved-from object won't also destroy the resources that it just handed over to the moved-to object.

### misc conventions and tips
- [different value category terminology (lvalue, rvalue, xvalue, etc.)](https://github.com/tedklin/pseudoblog/blob/master/cpp_notebook/primer/ch-04.md#chapter-4-expressions)
- when to use move operations
	- [pass-by-value-and-std::move vs pass-by-reference for constructors](https://stackoverflow.com/questions/51705967/advantages-of-pass-by-value-and-stdmove-over-pass-by-reference)
	- [see second answer here](https://stackoverflow.com/questions/3413470/what-is-stdmove-and-when-should-it-be-used)
- [some other considerations for when to define move constructors and assignments for our own types (read all answers!)](https://stackoverflow.com/questions/11077103/when-to-use-move-constructors-assignments)
