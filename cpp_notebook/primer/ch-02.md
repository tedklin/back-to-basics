# chapter 2: variables and basic types

## primitive built-in types (2.1)

#### new core ideas
- arithmetic types
- conversion rules
- literals
	- scientific notation for floating point literals
	- escape sequences
	- specifying types of literals with prefixes or suffixes

#### misc conventions and tips
- unless you need to get close to hardware, here are general rules of thumb for arithmetic types (justifications in section 2.1.1):
	- use an *unsigned* type prefix when you know that the values **cannot** be negative.
		- *unsigned* by itself is an abbreviation for *unsigned int*.
	- use *int* for integer arithmetic. if you need larger integers, use *long long*.
	- use *double* for floating-point computations.
	- **don't use plain *char* or *bool* in arithmetic expressions**. use them only to hold characters or truth values. if you really need a tiny integer, explicitly specify *signed char* or *unsigned char*.
	- **avoid undefined and implementation-defined behavior**, for example:
		- **don't** assign an out-of-range value to an object of signed type.
		- **don't** mix signed and unsigned types.
		- **don't** assume that the size of an int is a fixed and known value.
- two string literals that appear adjacent to one another and that are separated by only spaces, tabs, or newlines are automatically concatenated into a single literal.
	- useful for writing string literal that's too large to fit comfortably on a single line
- [an example use case of literal prefix](http://www.cplusplus.com/forum/beginner/106449/#msg576166)


## variables (2.2)

#### new core ideas
- initialization (2.2.1)
	- **initialization is not assignment**, even though they both use the = symbol. 
		- initialization happens when a variable is given a value when it is created.
		- assignment obliterates an object's current value and replaces that value with a new one.
	- list initialization
	- default initialization
- declaration vs definition (2.2.2)
	- *extern* keyword
	- to use the same variable in multiple files, we must **define** that variable in **one** file. other files that use that variable must **declare**, but not define, that variable.
- rules for identifiers (2.2.3)

#### misc conventions and tips
- **initialize every object of built-in type!**
	- uninitialized variables cause runtime problems!
- define variables close to where they're first used.
- **almost always a bad idea** to define a local variable with the same name as a global variable that the function uses or might use.
	- the :: scope operator can override default scoping rules, but again, try to avoid this.


## compound types (2.3)

#### new core ideas
- an **lvalue reference** (signified by a declarator with the *&* prefix) refers to (is another name for) its initializer.
	- refers to a single object (its initializer) throughout its lifetime.
	- references are not objects themselves.
- a **pointer** (signified by a declarator with the * prefix) points to another type.
	- unlike a reference, a pointer is an object in its own right.
	- a pointer holds the address of another object.
		- **address-of operator *&* **
	- the **dereference operator * ** yields the object that a pointer points to.
- pointer usage
	- a *valid* pointer is one that:
		- points to an object
		- points to the location just immediately past the end of an object
		- is a null pointer
	- we can initialize a pointer as a null pointer using the literal *nullptr* (C++11)
	- we can use valid pointers in conditions
		- null pointers evaluate to false
		- nonzero pointers evaluate to true
	- *void** pointers can hold the address of objects of any type, but are limited in usage.

#### misc conventions and tips
- the & and * declarator prefixes have nothing to do with the & (address-of) and * (dereference) operators.
	- think of them as completely different symbols!
- older programs might use a preprocessor variable named *NULL* from *cstdlib* to initialize a null pointer.
	- modern c++ should use *nullptr* instead.
- **initialize all pointers!**
	- ***common theme: uninitialized variables cause undefined behavior!***
	- if possible, define a pointer only after the object to which it should point has been defined. otherwise initialize as *nullptr*.
	


## things to follow up on
- what does it mean to be a pointer "one location past the end of an object"