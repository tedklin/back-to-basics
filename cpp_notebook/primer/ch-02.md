# chapter 2: variables and basic types

## primitive built-in types (2.1)

### new core ideas
- arithmetic types
- conversion rules
- literals
	- scientific notation for floating point literals
	- escape sequences
	- specifying types of literals with prefixes or suffixes

### misc conventions and tips
- unless you need to get close to hardware, here are general rules of thumb for arithmetic types (justifications in section 2.1.1):
	- use an *unsigned* type prefix when you know that the values **cannot** be negative.
		- *unsigned* by itself is an abbreviation for *unsigned int*.
	- use *int* for integer arithmetic. if you need larger integers, use *long long*.
	- use *double* for floating-point computations.
	- **don't use plain *char* or *bool* in arithmetic expressions**. use them only to hold characters or truth values. if you really need a tiny integer, explicitly specify *signed char* or *unsigned char*.
	- **avoid undefined and implementation-defined behavior**, for example:
		- **don't** assign an out-of-range value to an object of signed type.
		- **don't** mix signed and unsigned types.
		- **don't** assume that the size of an int is a fixed and known value.
- two string literals that appear adjacent to one another and that are separated by only spaces, tabs, or newlines are automatically concatenated into a single literal.
	- useful for writing string literal that's too large to fit comfortably on a single line
- [an example use case of literal prefix](http://www.cplusplus.com/forum/beginner/106449/#msg576166)


## variables (2.2)

### new core ideas
- initialization (2.2.1)
	- **initialization is not assignment**, even though they both use the = symbol. 
		- initialization happens when a variable is given a value when it is created.
		- assignment obliterates an object's current value and replaces that value with a new one.
	- list initialization
	- default initialization
- declaration vs definition (2.2.2)
	- *extern* keyword
	- to use the same variable in multiple files, we must **define** that variable in **one** file. other files that use that variable must **declare**, but not define, that variable.
- rules for identifiers (2.2.3)

### misc conventions and tips
- **initialize every object of built-in type!**
	- uninitialized variables cause runtime problems!
- define variables close to where they're first used.
- **almost always a bad idea** to define a local variable with the same name as a global variable that the function uses or might use.
	- the :: scope operator can override default scoping rules, but again, try to avoid this.


## compound types (2.3)

### new core ideas
- base type vs declarator
	- in the following example, *int* is the base type
	- i, *p, and &r are declarators.
	- 1024, &i, and i are initializers.

~~~
	int i = 1024, *p = &i, &r = i;
~~~

- an **lvalue reference** (signified by a *declarator* with the *&* type modifier) refers to (is another name for) its initializer.
	- refers to a single object (its initializer) throughout its lifetime.
	- references are not objects themselves.
- a **pointer** (signified by a *declarator* with the * type modifier) points to another type.
	- unlike a reference, a pointer is an object in its own right.
	- a pointer holds the address of another object.
		- **address-of operator &**
	- the **dereference operator &ast;** yields the object that a pointer points to.
		- can only be used on a valid pointer that points to an object.
- pointer usage
	- a *valid* pointer is one that:
		- points to an object
		- points to the location just immediately past the end of an object
		- is a null pointer
	- we can initialize a pointer as a null pointer using the literal *nullptr* (C++11) or the literal 0.
	- we can use valid pointers in conditions
		- null pointers evaluate to false
		- nonzero pointers evaluate to true
	- *void** pointers can hold the address of objects of any type, but are limited in usage.
- references to pointers, pointers to pointers

### misc conventions and tips
- the & and * symbols used in declarations have nothing to do with the & (address-of) and * (dereference) operators.
	- think of them as completely different symbols!
- older programs might use a preprocessor variable named *NULL* from *cstdlib* to initialize a null pointer.
	- modern c++ should use *nullptr* instead.
- **initialize all pointers!**
	- ***common theme: uninitialized variables cause undefined behavior!***
	- if possible, define a pointer only after the object to which it should point has been defined. otherwise initialize as *nullptr*.
- style choice for type modifiers in declarations:

~~~
// confusing
int* p1, p2; // p1 is a pointer to int, p2 is an int!
~~~

~~~
// good
int *p1, *p2; // both p1 and p2 are pointers to int
~~~

~~~
// good
int* p1; // p1 is a pointer to int
int* p2; // p2 is a pointer to int
~~~


## *const* qualifier (2.4)

### new core ideas
- *const*-ness of a variable only matters for operations that might change it.
- **by default, const objects are local to a file.**
	- when we define a const with the same name in multiple files, it is as if we had written definitions for separate variables in each file
	- to define a single instance of a const variable across multiple files, use the *extern* keyword on both its definition and declaration(s).
	
uses of the const qualifier:

~~~
int i = 42;
const int &r1 = i; // reference to object of type const int
~~~
- ***reference to const* just means we can't use that reference to modify the object to which the reference is bound.**
	- whether a reference refers to a const or nonconst type affects what we can do with that reference, not whether we can alter the binding of the reference itself (we can't alter the binding of any reference). 
- we can bind a *reference to const* to any expression that can be converted to the type of the reference, including:
	- a **non**const object, a literal, or a more general expression.
	- behind the scenes: unnamed **temporary objects** are created by compiler to store results from evaluating expressions / conversions.

~~~
double dval = 3.14;
const double *cptr = &dval; // pointer to object of type const double
~~~
- ***pointers to const*** have the same general idea as references to const.
	- **defining a pointer as a pointer to const affects only what we can do with the pointer.**
	- we can use a pointer to const to point to a **non**const object
- **important to remember that there is no guarantee that an object pointed to by a pointer to const won't change by other means.**

~~~
int errNumb = 0;
int *const currErr = &errNumb; // const pointer to object of type int

const double pi = 3.14;
const double *const pip = &pi; // const pointer to object of type const double
~~~
- because pointers are objects, we can have a pointer that is itself const.
- ***const pointers*** are pointers that can't change what they're pointing to after initialization. (same behavior as any const object)
- **the fact that a pointer is itself const says nothing about whether we can use the pointer to change the underlying object.**
- *top-level const* vs *low-level const*
	- top-level const indicates that an object itself is const. it is ignored when we copy an object.
	- low-level const indicates that a pointer or reference point/refer to a const (appears in the base type of compound types). when we copy an object, both objects must have the same low-level const qualification or there must be a conversion between the types of the two objects.
	
constant expressions (skimmed)

- constant expressions are expressions whose values cannot change and that can be evaluated at compile time.
	- a literal or a const object that is initialized from a constant expression.
- we can ask the compiler to verify that a variable is a constant expression by using the *constexpr* keyword in its declaration. (C++11)
	- can only use on literal types (arithmetic types, reference, and pointers)
	- imposes a top-level const, so order would look different from previous rules.

### misc conventions and tips
- https://isocpp.org/wiki/faq/const-correctness
- **read declarations from right to left!**
- generally a good idea to use *constexpr* for variables that you intend to use as constant expressions.


## dealing with types (2.5)

### new core ideas
- type aliases
	- can be declared with the *typedef* keyword (old) or *alias declaration* with the *using* keyword (C++11)
	- after being defined, type aliases can appear wherever a type name can appear
	- can be tricky with pointers
- 
	

### misc conventions and tips



## things to follow up on
- what does it mean to be a pointer "one location past the end of an object"
- if you bind a reference to const to a nonconst object, then change the nonconst object directly, does the reference to const also change when you next use it? intuition says yes, but the temporary object concept says no.