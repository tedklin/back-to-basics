# chapter 3: strings, vectors, and arrays

## namespace *using* declarations (3.1)

### new core ideas
- the **scope operator ::** says that the compiler should look in the scope (namespace) of the left-hand operand for the name of the right-hand operatand
- a ***using*** declaration lets us use a name from a namespace without qualifying the name with *(namespace)::* prefix
	- a separate *using* declaration is required for each name

~~~
#include <iostream>
#include <string>
using std::cin; using std::cout;
using std::string;
int main() {
	string i;
	cin >> i; // cin is a synonym for std::cin
	cout << i << '\n'; // cout is a synonym for std::cout
	return 0;
}
~~~

### misc conventions and tips
- **code in headers should not use *using* declarations**
	- recall contents of a header are copied into the including programs text. if a header has a *using* declaration, then every program that includes that header gets that same *using* declaration.


## library *string* type (3.2)

### new core ideas
- strings are not *containers*, but support many container operations.
- string initialization
	- *default initialize* to empty string (covered before in ch2).
	- *copy initialize* copies the initializer on the right-hand side of an = sign. this can be used with a single initializer.
	- *direct initialize* omits the = sign and can be used with initializers that consist of more than one value.
~~~
// how i initialize a string
string s1; // default initialization to the empty string
string s2 = s1; // s2 is a copy of s1 (copy initialized)
string s3 = "value"; // s3 is a copy of the string literal (copy initialized)
string s4(n, 'c'); // initialize s4 with n copies of the character 'c' (direct initialized)
~~~

- classes can define how objects are created/initialized, operations that are called by name, and what various operator symbols (<<, +, etc.) mean when applied to objects of the class' type.
- string operations
	- ***size()*** returns the **unsigned** type *string::size_type*
	- the ***subscript operator [ ]*** also takes a *string::size_type* **(unsigned)** value that denotes the zero-indexed position of the character we want to access and returns a *reference* to that character.
		- **we generally do not need to know / care about the precise type (just use *auto* and decltype(s.size()) ), but we need to remember that indexing is generally unsigned!**
		- valid range is >=0 && < size()
			- **the result of using an index out of range is undefined.**
			- **subscripting an empty string is undefined!**
		- any time we use a subscript, we must ensure that there is a value at the given location.
			- in this use case, we would check that the string isn't empty before using the [ ] operator.
~~~
// string operations
// 's' is string, 'os' is output stream, 'is' is input stream
// positions are zero-indexed

os << s // writes s onto os, returns os
is >> s // reads whitespace-separated string from is into s, returns is
getline(is, s) // reads a line of input from is into s (not including the newline), returns is.
s.empty() // returns true if s is empty, otherwise returns false
s.size() // returns the (unsigned size_type) number of characters in s
s[n] // returns a reference to the char at position (unsigned size_type) n in s.
s1 + s2 // returns a string that is the concatenation of s1 and s2
s1 = s2 // replaces characters in s1 with a copy of s2

// the strings s1 and s2 are equal if they contain the same characters.
// equality is case sensitive. 
// comparisons use case-senstive dictionary ordering.
s1 == s2 // !=, <, <=, >, >=
~~~

- string concatenation
	- the string library lets us convert both character literals and character string literals to strings (so we can automatically concatenate them).
	- **at least one operand to each + operator must be of *string* type.**
	- **string literals are not of type *string*.** (from the C++ standard library)
~~~
// examples of legal and illegal concatenation
string s4 = s1 + ", " + s2 + '\n'; // ok
string s5 = "hello" + ", " + s2; // ERROR: no string operand for first + operator
string s6 = s1 + ", " + "world"; // ok, right equivalent to (s1 + ", ") + "world"
~~~

- processing strings
	- the ***cctype* header** has functions for interpreting characters and changing characteristics like upper/lowercase
	- [**range-based *for* loop**](insertlink) is good for processing every character in a string. (C++11)
		- the *auto* type specifier is useful here.
	- **to change the value of the characters in (nonconst) string, we must define the loop variable as a reference type.**
~~~
// example of changing the characters in a string by reference
string s = "hello world!!!";
for (auto &c : s) {
	c = toupper(c); // cctype function returns uppercase version of argument
}
cout << punct_cnt << '\n';
~~~

### misc conventions and tips
- direct initialize is preferred when initializing objects with multiple values (parameters?)
- **avoid using signed *int* variables in subscript operators *[ ]* or expressions that use *size()*.**
- the C++ library incorporates the C library. the C++ version of C library headers are c*name* (remove the .h suffix and precede the name with the letter 'c').
	- when we include *cctype*, we are actually including the C++ version of the C library header *ctype.h*. 
	- using the c*name* form in C++ lets us access the C library header's namespace through *std*.


## library *vector* type (3.3)

### new core ideas
- a ***vector*** is a *class template*
	- templates are not themselves classes or functions.
	- to specify which actual class to instantiate from a template, we supply additional information inside angle brackets following the template's name.
- a vector is a *container* containing other objects all of the same type.
	- we specify the type of the objects a vector will hold inside angle brackets.
- vector initialization
	- default initialize to an empty vector of the specified type.
		- the most common way of using vector is to define an empty vector to which elements are added as their values become known at runtime.
	- copy elements from another vector of the same type (using either direct or copy initialization like with strings)
	- list initialize using { } curly braces (direct or copy initialization)
	- direct initialize from a specified number of elements (with the option of providing a default initial value for all elements)
	- direct initialize from an array (using array pointers, see section below on arrays)
~~~
// how i initialize a vector
vector<T> v1; // default initialize empty vector of type T
vector<T> v2 = v1; // v2 has a copy of each element in v1
vector<T> v3 = {a, b, c}; // v3 is copy-list-initialized
vector<T> v4(n, val); // v4 has n elements each with value val
vector<T> v5(n); // v5 has n elements each with type T's value-initializing value
vector<T> v6(begin(myIntArray), end(myIntArray)); // v6 is a vector corresponding to a separate int array
~~~

- vector operations
	- ***push_back*** takes a value and "pushes" it as a new last element onto the "back" of the vector (appends value to vector).
		- **note that a range *for* loop must not change the size of the sequence over which it is iterating.**
	- other operations on vector are similar to operations on string.
		- **the *size()* operation and *subscript operator [ ]* use an unsigned type** (*vector< T >::size_type*).
			- like with strings, subscript returns a *reference* to the element at the specified index.
			- **remember to only subscript in range and on nonempty vectors, otherwise behavior is undefined!**
		- two vectors can be compared if the element type can be compared. 
			- dictionary ordering like strings.

### misc conventions and tips
- [direct initializers are generally more permissible, but can lead to the "most vexing parse" disambiguity problem.](https://en.cppreference.com/w/cpp/language/direct_initialization)
	- for now stick with copy initialization and only use direct initialization when necessary.
- be careful about curly braces vs parentheses!
	- also, if we use braces, but there is no way for the compiler to use the initializers to list initialize the object, the compiler would then try to use those initializers to construct the object (as if they were inside parentheses).
- vectors grow efficiently.
	- recall amortization in cs61b!
	- only specify number of elements / initial value when you want all or most elements to have that initial value.
- use [range for loops]() wherever possible to avoid possible subscripting bugs.


## intro to iterators (3.4)

### new core ideas
- **all library containers (and string) support iterators.**
- types that support iterators have members that return iterators.
	- iterators have type *(container)::iterator* or *(container)::const_iterator* 
		- in general, we don't know / care about the precise type that an iterator has (just use *auto* to initialize).
	- ***begin()*** for iterator on the first element.
	- ***end()*** for one past the last element ("off the end iterator"). 
		- *end()* is nonexistent and is used as a marker to indicate when we have processed all elements in the container.
	- ***cbegin()* and *cend()* for read-only const versions.** (C++11)
		- returns a read-only *const_iterator* type even if container itself is non*const*.
- standard iterator operations
	- dereference an iterator to obtain the underlying element.
		- **dereferencing an invalid iterator or an off-the-end iterator has undefined behavior.**
		- **incrementing an off-the-end iterator is not allowed.**
	- iterators are equal (==) if they denote the same element or if they are both off-the-end iterators for the same container.
	- **the *arrow operator ->* combines dereference and member access into a single operation.**
		- *iter->mem* is a synonym for *(&ast;iter).mem*
	- increment / decrement to move iterator forward/backward one position
~~~
// standard container iterator operations
*iter // dereferencing returns a reference to the element denoted by iterator iter
iter->mem // equivalent to (*iter).mem
++iter // increment iter to refer to the next element in the container
--iter // decrement iter to refer to the previous element in the container
iter1 == iter2 // see bullet point above
~~~

~~~
// example iterator in a traditional for loop
// capitalize all characters in s
string s = "blahblah";
for (auto iter = s.begin(); iter != s.end(); ++iter) {
	*iter = toupper(*iter);
}
~~~

- **iterator arithmetic**
	- *vector* and *string* support adding/subtracting integer values to iterators to move multiple positions.
		- the resulting iterator must denote elements in the same container.
		- we can also subtract two iterators of the same vector or string. returns signed integral type *difference_type*.
		- useful for things like binary search where we have to iterate from the middle.
	- we can directly compare iterators in the same container with normal relational operators (<, <=, etc). the value for comparison is the iterator's position in the container.

### misc conventions and tips
- **generic programming**
	- the example of an iterator in a traditional for loop above works equally well for various kinds of containers provided by the library.
		- some iterators don't have the < operator. by routinely using !=, we don't have to worry about the precise type of the container we're processing.
- ***common theme: use a const type when you need to read but not write to an object.***
	- use cbegin() and cend() accordingly!
- **loops that use iterators should not add elements to the container to which the iterators refer.**
	- any operation that changes the size of a vector potentially invalidates all iterators into that vector.


## built-in arrays (3.5)

### new core ideas
- arrays are a fixed-size data structure
- built-in arrays are a compound type
	- array declarators are of form *name[dim]*
		- **dimension must be a constant expression greater than zero.**
- initialization
	- **arrays follow default initialization rules for built-in types (undefined if defined inside a function)**
	- we can explicitly initialize array elements using list initialization.
		- don't need to specify dimension.
		- specifying a dimension greater than the number of initializers in the list makes remaining elements *value initialized*.
	- character arrays can be initialized from a string literal.
		- automatically adds the **null character '\0'** at the end of every string literal!
	- **we cannot copy-initialize an array from another array or assign arrays to each other.**
	- we cannot initialize an array from a vector, but we can initialize a vector from an array (see in vector section).
~~~
// how i initialize arrays
T arr[] = {a, b, c};
T arr[n] = {}; // zeroed array (value intialization)
~~~

- processing 
	- similar to vectors and strings, with the exception that arrays are fixed size.
	- *range for* and *subscript operator [ ]* both access elements of array.
		- **use unsigned type *size_t* from the *cstddef* header to define variables used to subscript an array.**
	- as with strings and vectors, **remember to check that subscripts are kept in range!**
- pointers and arrays
	- **the compiler automatically substitutes the name of an array with a pointer to its first element.**
		- if we had an array named *nums*, using the name *nums* actually gives us *&nums[0]*.
		- this conversion does not happen when we use decltype.
	- **pointers that address elements in an array support the same operations as *iterators* on vectors or strings**
		- we can take the address of the nonexistent element one past the last element of an array to create something like the "off-the-end iterator".
			- doing this directly is error-prone.
		- the ***iterator* header** has functions ***begin(myArray)*** and ***end(myArray)*** that take an array as an argument and return the beginning and off-the-end pointers. (C++11)
- **pointer arithmetic**
	- same operations as iterator arithmetic!
		- result of subtracting two pointers is signed integral library type *ptrdiff_t*.
	- the built-in subscript (on arrays only) can actually take negative values because of its underlying pointer arithmetic, but ignore this functionality for now!
- interfacing with old code or C
	- C++ supports C functions for C-style character strings, but they are more prone to error and should not be used. 
		- a C-style character string is a convention for storing a string in a character array with a null terminator. 
		- we can use a null-terminated character array anywhere that we use a string literal. (for example, initializing a C++ standard library *string*).

### misc conventions and tips
- *T arr[n] = {}* for element value-initialization only works in C++, *int arr[n] = {0}* works in both C and C++.
- read complicated array declarations starting with the array name and going out.
~~~
// complicated array declarations
int *ptrs[10]; // ptrs is an array of ten pointers to int
int (*pArray)[10] = &arr; // pArray points to an array of 10 ints
int (&refArray)[10] = arr; // refArray refers to an array of 10 ints
~~~
- **use *vectors* and *strings* when you can!**


## multi-dimensional arrays (3.6)

### new core ideas
- operation is intuitive
~~~
int myMatrix[3][4] = {
	{0, 1, 2, 3};
	{4, 5, 6}; // default initializes missing elements
	{8, 9, 10, 11};
};
myMatrix[1][3] = 7; // assign previously default-initialized element to 7

// references are necessary to avoid automatic array-to-pointer conversion!
for (auto &row : myMatrix) {
	for (auto &col : row) {
		col *= 2;
	}
}
~~~
- the name of a multidimensional array is automatically converted to a pointer to the first inner array.
- refer to Primer for details on multidimensional array use.

## things to follow up on
- my program compiles and runs without the #include directive for cctype. is it necessary/good practice to include it anyways?
	- same for *string*
	- answer - [include everything to guarantee functionality across different compilers](https://stackoverflow.com/questions/16506095/do-i-have-to-use-include-string-beside-iostream)
