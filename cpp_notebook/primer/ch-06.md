# chapter 6: functions

## basics (6.1)

### new core ideas
- function call
	- execution of a function begins with the (implicit) definition and initialization of its parameters (listed in the function definition) from arguments the caller passes in.
		- the type of each argument must match the corresponding parameter in the same way that the type of any initializer must match the type of the object it initializes.
			- the type of the arguments we pass in must be convertible (and will be converted) to the type of the parameter, just like in regular initialization.
	- the return type cannot be an array type or a function type, but can be a pointer to an array or function (see below).
- scope and lifetime
	- the ***scope*** of a name is the part of the program's text in which that name is visible.
	- the ***lifetime*** of an object is the time during the program's execution that the object exists.
- local objects
	- are parameters and variables defined inside a function body.
	- ordinary local objects are created when the function's control path passes through the variable definition and destroyed when control passes through the end of the block in which the variable is defined.
		- aka ***automatic objects***
		- default initialized if no initializer (to undefined if built-in type).
		- parameters are also automatic objects.
	- a ***local static object*** (a local variable with keyword *static*) persists until the program terminates.
		- initialized before the first time execution passes through the object's definition.
		- value initialized if no initializer (to zero if built-in type).
		- subsequent calls ignore(?) the initialization statement because the variable already exists (initialization is not assignment!).
~~~
size_t count_calls() {
	static size_t ctr = 0;
	return ++ctr;
}

int main() {
	// prints the numbers from 1 through 10 inclusive
	for (size_t i = 0; i != 10; ++i) {
		cout << count_calls() << '\n';
	}
	return 0;
}
~~~

- function declarations
	- aka *function prototype*
	- a function may only be defined once but can be declared multiple times (like variables)
	- a function declaration is just like a function definition except the function body is replaced with a semicolon
		- parameter names are not required, but can help users of the function understand what the function does.
	- **functions should be declared in header files and defined in source files.**
		- the source file that defines a function should #include the header that declares the function.
		- these files can be compiled separately and linked.


### misc conventions and tips
- [compiling and linking multiple files with g++](https://stackoverflow.com/questions/3202136/using-g-to-compile-multiple-cpp-and-h-files)

## argument passing (6.2)

### new core ideas
- **parameter initialization works the same way as variable intialization!**
- **passing arguments by value**
	- when we initialize a *nonreference*-type variable, the value of the initializer is **copied**.
		- changes made to the variable inside the function have no effect on the initializer.
	- pointers are also copied and can be used normally with address arguments (but generally use pass by reference instead).
- **passing arguments by reference**
	- reference parameters allow a function to change the value of corresponding arguments.
	- using reference parameters avoids large copies.
	- reference pointers can be used to "return" multiple values from a function.
- **const parameters and arguments**
	- refer back to ch2 for initialization rules!
		- recall plain reference type matching rules and top-level / low-level const rules.
	- **reference parameters that are not changed inside a function should be *references to const*.**
		- using a plain reference type parameter not only misleads the function caller, but also greatly limits the type of arguments that can be passed in! (can't pass const, literal, or any object that requires conversion)
- array parameters
	- recall from ch3 that we cannot copy an array, and when we use an array it's usually converted to a pointer.
	- k

### misc conventions and tips
- C programmers often use pointer parameters to access objects outside a function. C++ programmers generally use reference parameters instead.
- [pass by reference to const vs pass by value](https://stackoverflow.com/questions/270408/is-it-better-in-c-to-pass-by-value-or-pass-by-constant-reference)

## basics (6.1)

### new core ideas

### misc conventions and tips


## basics (6.1)

### new core ideas

### misc conventions and tips


## basics (6.1)

### new core ideas

### misc conventions and tips


## things to follow up on